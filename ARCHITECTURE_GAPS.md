# Toumo PRD Gap Analysis & Architecture

> Generated by architecture analysis against PRD.md
> Date: 2025-07-14

## Summary

| # | Gap | Status | Priority |
|---|-----|--------|----------|
| 1 | Live Preview 设备框架 | ❌ 未实现 | High |
| 2 | 组件内部 Patch 连线编辑 UI | ⚠️ 部分实现 (store有CRUD，无UI) | High |
| 3 | 预设案例数据不完整 | ⚠️ 部分实现 | Medium |
| 4 | Patch 框选多选 | ⚠️ 部分实现 (只选第一个) | Medium |
| 5 | 组件实例覆写运行时生效 | ⚠️ 部分实现 | High |
| 6 | loadProject 不恢复 Patch/DisplayState 数据 | ❌ 未实现 | High |
| 7 | 组件关键帧行的 Patch 编辑器切换 | ❌ 未实现 | Medium |
| 8 | Sugar 预设交互模板 UI | ⚠️ 部分实现 (engine有，UI缺) | Low |
| 9 | 三级曲线覆盖在过渡动画中的应用 | ⚠️ 部分实现 | Medium |
| 10 | FilesPanel 保存/加载不含完整数据 | ❌ 未实现 | High |

---

## Gap 1: Live Preview 设备框架（iPhone/Android 外壳）

### PRD 要求
> **§6.1 Live Preview (左侧)**
> - 始终显示当前原型的可交互预览
> - 实时响应编辑器中的修改
> - **支持设备框架（iPhone/Android）**

### 当前状态
**❌ 未实现**

`src/components/LivePreview/index.tsx` 中：
- 有 `frameSize` 用于缩放预览区域
- 有 `DEVICE_PRESETS`（在 store 中定义了 iPhone 14 Pro/14/SE/Android/iPad 尺寸）
- **但没有任何设备外壳 UI**：预览区域只是一个黑色背景的 div，没有手机边框、刘海、Home 指示器等视觉元素

### 架构方案

#### 数据模型变更
```typescript
// 新增到 EditorState
interface EditorState {
  // ... existing
  deviceFrame: DeviceFrameType;  // 当前选择的设备框架
}

type DeviceFrameType = 'none' | 'iphone-14-pro' | 'iphone-14' | 'iphone-se' | 'android' | 'ipad';
```

#### 新增组件
- `src/components/LivePreview/DeviceFrame.tsx` — 设备外壳渲染组件

#### 组件结构
```
DeviceFrame
├── 外壳 SVG/CSS（圆角边框、按钮、刘海/灵动岛）
├── 状态栏（时间、信号、电池）
├── children（实际预览内容）
└── Home 指示器（底部横条）
```

#### Store 变更
在 `useEditorStore` 中新增：
- `deviceFrame: DeviceFrameType` 状态字段（默认 `'iphone-14-pro'`）
- `setDeviceFrame: (frame: DeviceFrameType) => void` action

#### 文件路径
- `src/components/LivePreview/DeviceFrame.tsx` — 主组件
- `src/components/LivePreview/deviceFrames.ts` — 各设备的尺寸/样式配置数据

### 实现步骤
1. 在 store 中添加 `deviceFrame` 状态和 setter
2. 创建 `deviceFrames.ts` 配置文件，定义每种设备的外壳参数（圆角、边框宽度、刘海形状、Home 指示器等）
3. 创建 `DeviceFrame.tsx` 组件，用 CSS 绘制设备外壳（避免引入大型 SVG 资源）
4. 在 `LivePreview/index.tsx` 的 header 区域添加设备选择下拉框
5. 用 `DeviceFrame` 包裹现有的预览内容 div

---

## Gap 2: 组件内部 Patch 连线编辑 UI

### PRD 要求
> **§7 组件与状态映射**
> - 组件内部有自己的 Patch 连线（交互逻辑）
>
> **§8 Data Model**
> ```typescript
> interface Component {
>   patches: Patch[];               // 组件的 Patch 节点
>   connections: PatchConnection[]; // 组件的 Patch 连线
> }
> ```

### 当前状态
**⚠️ 部分实现**

**Store 层已实现：**
- `ComponentV2` 类型定义了 `patches?: Patch[]` 和 `connections?: PatchConnection[]`
- Store 有 `addComponentPatch`、`removeComponentPatch`、`addComponentConnection`、`removeComponentConnection` 四个 action（`useEditorStore.ts` L4099-4119）

**UI 层未实现：**
- `ComponentPanel.tsx` 只显示 patches 数量（`{component.patches?.length || 0} patches`），没有编辑入口
- 没有组件级 Patch 编辑器视图
- 进入组件编辑模式（`enterComponentEditMode`）时，Patch 编辑器仍显示画布级 patches，不会切换到组件的 patches

### 架构方案

#### 数据模型变更
无需变更，`ComponentV2` 已有 `patches` 和 `connections` 字段。

#### 核心思路
PatchCanvas 需要感知「当前编辑上下文」：画布级 or 组件级。通过 `editingComponentId` 判断。

#### Store 变更
新增 computed selector：
```typescript
// 当前上下文的 patches/connections（画布级 or 组件级）
getActivePatches: () => Patch[]
getActiveConnections: () => PatchConnection[]
addActivePatch: (patch: Patch) => void
removeActivePatch: (id: string) => void
addActiveConnection: (conn: PatchConnection) => void
removeActiveConnection: (id: string) => void
```

#### 新增/修改的组件
- **修改** `src/components/InteractionManager/PatchCanvas.tsx` — 读取 active context
- **修改** `src/components/InteractionManager/PatchToolbar.tsx` — 添加 patch 时写入 active context
- **修改** `src/components/InteractionManager/index.tsx` — 显示当前编辑上下文标识

#### 文件路径
无需新增文件，修改现有文件即可。

### 实现步骤
1. 在 store 中添加 `getActivePatches()` / `getActiveConnections()` 等 context-aware 方法
2. 修改 `PatchCanvas` 使用 context-aware selectors 替代直接读 `s.patches`
3. 修改 `PatchToolbar` 的 addPatch 调用，根据 `editingComponentId` 决定写入画布级还是组件级
4. 在 `InteractionManager` 顶部添加面包屑导航（如 "Canvas > ButtonComponent"）
5. 在 `ComponentPanel` 中添加 "Edit Patches" 按钮，点击进入组件编辑模式

---

## Gap 3: 预设案例数据不完整

### PRD 要求
> **§12 Files Panel**
> - **预设案例** — 内置多个示例项目（按钮交互、卡片展开、Tab 切换等），点击即可加载
> - 每个项目独立序列化（keyframes + elements + **patches + connections + variables + components**）

### 当前状态
**⚠️ 部分实现**

`src/components/FilesPanel/index.tsx` 中有 5 个预设：
- Button Interaction、Card Expand、Tab Switch、Toggle Switch、Drag to Dismiss

**问题：**
1. 预设只包含 `keyframes`、`transitions`、`components`、`frameSize`，**缺少**：
   - `sharedElements` — 没有图层数据，加载后画布为空
   - `displayStates` — 没有显示状态覆盖
   - `patches` / `patchConnections` — 没有交互逻辑
   - `variables` — Tab Switch 和 Toggle 有变量但没有对应的 patch 连线
2. 加载预设后用户看到的是空画布 + 空 patch 编辑器，无法体验交互

### 架构方案

#### 数据模型变更
无需变更类型，但预设数据结构需要完整化。

#### 完整预设数据结构
```typescript
interface PresetProject {
  name: string;
  description: string;
  keyframes: Keyframe[];
  sharedElements: KeyElement[];
  displayStates: DisplayState[];
  patches: Patch[];
  patchConnections: PatchConnection[];
  variables: Variable[];
  componentsV2: ComponentV2[];
  frameSize: Size;
  globalCurve: CurveConfig;
}
```

#### 文件路径
- `src/data/presets/buttonInteraction.ts` — 按钮交互完整数据
- `src/data/presets/cardExpand.ts` — 卡片展开完整数据
- `src/data/presets/tabSwitch.ts` — Tab 切换完整数据
- `src/data/presets/toggleSwitch.ts` — 开关完整数据
- `src/data/presets/dragDismiss.ts` — 拖拽关闭完整数据
- `src/data/presets/index.ts` — 统一导出

#### Store 变更
修改 `loadProject` 签名，支持完整数据：
```typescript
loadProject: (data: {
  keyframes: Keyframe[];
  sharedElements?: KeyElement[];
  displayStates?: DisplayState[];
  patches?: Patch[];
  patchConnections?: PatchConnection[];
  variables?: Variable[];
  componentsV2?: ComponentV2[];
  frameSize: Size;
  globalCurve?: CurveConfig;
}) => void;
```

### 实现步骤
1. 扩展 `loadProject` action 支持恢复所有字段（见 Gap 6）
2. 将预设生成函数从 `FilesPanel` 移到 `src/data/presets/` 目录
3. 为每个预设创建完整数据（含 sharedElements + displayStates + patches + connections）
4. 更新 `FilesPanel` 引用新的预设数据
5. 每个预设至少包含：2-3 个图层、2 个显示状态、1-2 个 patch 连线

---

## Gap 4: Patch 框选多选

### PRD 要求
> **§6.4 Interaction Manager — Patch 编辑器**
> - 支持拖拽添加新 Patch、Delete 删除、**框选多个**

### 当前状态
**⚠️ 部分实现**

`PatchCanvas.tsx` 中有框选（marquee）逻辑：
- 鼠标拖拽绘制选区矩形 ✅
- 选区可视化（蓝色边框 + 半透明背景）✅
- **但 mouseUp 时只选第一个**：
  ```typescript
  if (selected.length > 0) {
    setSelectedPatchId(selected[0].id);  // ← 只取第一个
  }
  ```
- Store 中只有 `selectedPatchId: string | null`（单选），没有 `selectedPatchIds: string[]`（多选）
- 没有多选后的批量操作（批量删除、批量移动）

### 架构方案

#### 数据模型变更
```typescript
// EditorState 新增
selectedPatchIds: string[];  // 多选 patch IDs（替代 selectedPatchId）
```

#### Store 变更
```typescript
// 新增 actions
setSelectedPatchIds: (ids: string[]) => void;
togglePatchSelection: (id: string) => void;  // Shift+Click 切换
removeSelectedPatches: () => void;            // 批量删除
moveSelectedPatches: (dx: number, dy: number) => void; // 批量移动
```

#### 修改的组件
- **修改** `PatchCanvas.tsx` — marquee mouseUp 改为 `setSelectedPatchIds(selected.map(p => p.id))`
- **修改** `PatchNode.tsx` — 支持多选高亮（`selectedPatchIds.includes(patch.id)`）
- **修改** `PatchCanvas.tsx` — Delete 键批量删除、节点拖拽时批量移动

### 实现步骤
1. Store 中添加 `selectedPatchIds: string[]` 和相关 actions
2. 保留 `selectedPatchId` 作为 Inspector 的焦点（多选时取最后一个）
3. 修改 marquee mouseUp：`setSelectedPatchIds(selected.map(p => p.id))`
4. 修改 PatchNode 点击：普通点击单选，Shift+Click 追加/移除
5. 修改 Delete 键处理：遍历 `selectedPatchIds` 批量删除
6. 修改节点拖拽：如果拖拽的节点在多选中，所有选中节点同步移动

---
